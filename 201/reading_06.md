# Reading 6

## Understanding The Problem Domain Is The Hardest Part of Programming (John Sonmez)

A significant challenge of programming is understanding the problem domain- the larger context or overall framework within which youare constructing the code. 

- If a coding challenge seems intimidating and too large to understand all at once- narrow down the problem domain to gain better understanding. 
- BEFORE starting to code, make sure you know the ins and outs of the challenge, and have a plan before starting. 

## Jon Duckett JavaScript & JQuery Book 

## Chapter 3- Object Literals

Objects can group together variables and functions. In an object...
- Variables become properties
  - The names of properties become keys. Keys can be set equal to values, and are known then to be "key/value pairs."
- Functions become methods

~~~
var ocean = {
  name: 'Pacific',
  sharks: true,
  blueWhales: 130,
  humpbackWhales: 100,
  fishTypes: ['salmon', 'trout', 'cod'],

  checkWhaleNumbers: function{
    return this.humpbackWhales + this.blueWhales;
  }
}
~~~

### Dot Notation

You can access properties or methods of an object by using dot notation, or square brackets. 

Name of the object --> period (member operator) --> name of the property or method in question
`var oceanName = ocean.name;` This would access the string "Pacific" in the object. 
`var totalWhales = ocean.checkWhaleNumbers();` This would access the method in the object. 

Alternative to dot notation: `var oceanName = ocean['name'];`

## Chapter 5- Document Object Model

**DOM = API (Application Programming Interface)** A DOM specifies how the browser fits together the HTML and how JavaScript can access that information. 


- Every element, attribute, and piece of text in an HTML piece corresponds to a DOM *element* node. 
- The *document node* is at the very top of the DOM tree, which is why when one wants to access something, you can say 'document.' 
- There are also *attribute* nodes, which are not children of the partnered element- they are part of it. 
- *Text* nodes are the base level- they do not have children elements. 

To access the DOM Tree: Locade the node of the element in question, and use its text, child elements, & attributes. 

### Selecting Individual Element Node

- `getElementById()` - Uses element's id attribute
- `querySelector()` - Uses CSS selector
- `parentNode` or `previous/nextSibling` or `firstChild/lastChild`

### Selecting Multiple Element Nodes

- `getElementByClassName()` - All elements with given class
- `getElementsByTagName()` - All elements with tag
- `querySelectorA11()` - All elements with CSS selector

### Working with Elements

Elements can be accessed, updated, created, and changed, by working through the DOM. Examples: `nodeValue` lets you access content in a text node and `createElement()` adds a new node to the tree. For a more complete list, see page 189.

### DOM Queries

When JavaScript wants to do something with information contained in the HTML file, it needs to reach it through the DOM. So, you can create a JavaScript variable that is a link to that information: `var firstItem = getElementById('one');` This accesses the element with an id of 'one.' 

### NodeLists

If a method can return a *collection* of items, it will, with a NodeList. You navigate to values in a *NodeList* like in an array- starting at 0. 

- Use the length property to see length of collection
- The item() method returns a node value. Or the [] like an array
- See page 197 for examples of times when a NodeList is returned. 

Example from page 198:
~~~
var elements = document.getElementsByClassName('hot')
if (elements.length >=1){
  var firstItem = elements.item(0);
}
~~~
In this code, a NodeList is generated by the first line. The if-statement checks how many elements are in the list, and gives the first item in the list a variable container. 

Query selector example:
~~~
var el = document.querySelector('li.hot');
el.className = 'cool';
~~~

#### Iterating through NodeList -->

This is a similar concept to moving through an array. It is helpful tp repeat code on multiple items. 

~~~
var hotItems = document.querySelectorAll('li.hot');
for (var i = 0; i <hotitems.length; i++) {
  hotItems[i].className = 'cool';
}
~~~

### Updating Content

You can either navigate to the text nodes, or work with the containing element. 

`document.getElementById('one').firstChild.nextSibling.nodeValue;`

In the code block about, **NodeValue** is used to access the text content, after having navigated to the element. 

TO CHANGE TEXT:
1. Access element `var itemOne = document.getElementById('one');
1. Get the text content `var elementText itemOne.firstChild.nodeValue;`
1. Change the text `elementText = elementText.replace('last');`
1. Update the item with the changed value `itemOne.firstChild.nodeValue = elementText;`

- Use the **textContent** property to collect content of an element and replace the entire content and any markup

### Adding and Removing Content

innerHTML works for changing details and fragments

1. Store new content in a variable
1. Select the element where new content will replace the old
1. Set the element's innerHTML property to new string

DOM Manipulation is good for individual nodes. Page 223 has a good example of adding an element to the DOM. 

1. Create new text node `createTextNode()`
1. Create element node `createElement()`
1. Combine element and text nodes 
1. Select the parent node in the DOM
1. Add the new pair of element to the tree `appendChild()`

To remove content:

1. Make sure the element to be removed is in a variable 
1. Store the parent element of the one being removed in a variable 
1. Use the `removeChild()` method with the parent and child elements.

### Writing on the Page

- `document.write()` Not for frequent use. It can be unreliable, and sometimes overwrite other text. 
- `element.innerHTML` Do not use for information from a user. This is a faster way, with less code, than DOM manipulation. 
- **DOM Manipulation** This method involves append and textContent and such, and is the most sound of the three. It does, however, take the most code. 


### Cross-Site Scripting XSS

- Adding HTML to a page using innerHTML or jQuery can expose the site to attackers
- XSS can give them access to the DOM, website cookies, session tokens, etc. 
- Protect your site with data validation. 
  - Prevent users from entering characters that are not necessary- especially characters used in code. 
- Do not place user data in script tags, HTML comments, tag names, attributes, or CSS values. 

### Attribute Nodes

- After getting an element node, you can use other methods on it. For example: `document.getElementById('one').getAttribute('class')`
  - Other potential methods: `getAttribute()` `hasAttribute()` `setAttribute()` `removeAttribute()`
  - Potential properties: className or Id


[Home](https://peymade.github.io/reading-notes/)